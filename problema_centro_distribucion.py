# -*- coding: utf-8 -*-
"""Untitled131.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16D2BEIqBL4P1xoXmH8EU0lzdSD_hjafv
"""

import numpy as np
import matplotlib.pyplot as plt
import networkx as nx

N=30 #Número de puntos de clientes
L=100
dL=10
x,y=[],[]
for xi in np.arange(-L,L+1,dL):
  for yi in np.arange(-L,L+1,dL):
    x.append(xi+np.random.randn()*dL*0.1)
    y.append(yi+np.random.randn()*dL*0.1)
M=len(x)
ind=list(np.random.randint(low=0, high=M, size=N))
demanda={k:np.random.randint(low=1, high=11) for k in ind} #demanda de cada cliente

links=[]
for i in range(M):
  for j in range(i+1,M):
    if(np.sqrt((x[i]-x[j])**2+(y[i]-y[j])**2)<=1.2*dL):
      links.append([i,j])

def dibujar(x,y,d, links):
  for i,j in links:
    plt.plot([x[i],x[j]],[y[i],y[j]],'k:')
  plt.plot(x,y,'.r')
  for i,dem in d.items():
    plt.plot(x[i],y[i],'sb', markersize=dem)
    plt.text(x[i],y[i],str(i))

  plt.axis('equal')

dibujar(x,y,demanda,links)

#Definición de las rutas entre todos los clientes y un punto central
def distancias(x,y,links,ind,src,D,P):
  G=nx.DiGraph()
  for i in range(len(x)):
    G.add_node(i)
  for a,b in links:
    G.add_edge(a,b,weight=np.sqrt((x[a]-x[b])**2+(y[a]-y[b])**2))
    G.add_edge(b,a,weight=np.sqrt((x[a]-x[b])**2+(y[a]-y[b])**2))

  for i in ind+[src]:
    for j in ind+[src]:
      if(i==j):
        D[i,j]=1e10
        P[i,j]=[]
      else:
        if((i,j) not in D.keys()):
          D[i,j]=nx.shortest_path_length(G,source=i,target=j,weight='weight')
          P[i,j]=nx.shortest_path(G,source=i,target=j,weight='weight')
  return D, P
src=420
D, P=distancias(x,y,links,ind,src,{},{})

def costeo(ind, x,y, links, D,P, src, draw):
  conectados=[]
  porconectar=[int(i) for i in ind]
  Dmax=sorted(np.unique(list(D.values())), reverse=True)[1]*2+100
  Cmax=30
  Distancia=500000
  Carros=[]
  if(draw):
    plt.figure(figsize=(12,12))
  contador=1000
  if(draw):
    dibujar(x,y,demanda,links)

  while(len(porconectar)>0 and contador>0):
    contador-=1
    if(Distancia>Dmax): #Hay que agregar un nuevo carro
      #print('Se comienza un nuevo carro')
      #print('Por conectar: ',porconectar)
      tmp=[src] #Carro sin comenzar recorrido
      Distancia=0
      CAP=0
      #Se busca en todos los que faltan por conectar, buscando que al agregarlos no se pase el tiempo máximo o la capacidad, incluyendo el regreso al origen
    dmin=1e10

    #print('Se va a comenzar de nuevo un nuevo nodo, se revisa desde el nodo: ',tmp[-1])
    for ni in porconectar:
      #print('Se evalúa el nodo: ',ni, 'Distancia acumulada: ',Distancia, 'Distancia necesaria: ',Distancia+D[tmp[-1],ni]+D[ni,src],'CAP:',CAP)
      if(Distancia+D[tmp[-1],ni]+D[ni,src]<Dmax and CAP+demanda[ni]<Cmax): #Si el cliente yendo al sitio y regresando no supera la distancia y no tiene problemas de capacidad.
        if(D[tmp[-1],ni]<dmin):
          dmin=min(dmin,D[tmp[-1],ni])
          path=[int(pi) for pi in P[tmp[-1],ni]]
          nodo=ni
          #print('Posible nodo a conectar: ',ni, ', Dmin=',dmin)

    if(dmin<1e9): #Se encontró algo más por agregar
      Distancia+=dmin
      tmp=tmp+path[1:]
      #print(porconectar, nodo)
      #print('Camino hasta el momento:',tmp, 'Nodo a remover: ',nodo)
      porconectar.remove(nodo)
      CAP+=demanda[nodo]
      #print('Se conecta: ',nodo, ', camino=',tmp,', CAP=',CAP, ' Distancia=',Distancia,'\n')

    else:
      Carros.append(tmp)
      #print('Se conectó al origen por no haber más forma de conectar otros nodos')
      #print(tmp)
      Distancia=1e9
      CAP=0
  Carros.append(tmp)
  Carros2=[]
  for c in Carros:
    path=[int(pi) for pi in P[c[-1],src]]
    c=c+path[1:]
    xp=[x[i] for i in c]
    yp=[y[i] for i in c]
    if(draw):
      plt.plot(xp,yp,'-', linewidth=3)
    Carros2.append(c)
  Carros=Carros2
  if(draw):
    plt.plot(x[src], y[src], 'sk', markersize=20)
  Ltot=0
  for c in Carros:
    for i in range(len(c)-1):
      Ltot+=np.sqrt((x[c[i]]-x[c[i+1]])**2+(y[c[i]]-y[c[i+1]])**2)

  return Carros, Ltot

from tqdm import tqdm
resultado=[]
P,D={},{}
Lmin=1e10
for i in tqdm(range(len(x))):
  src=i
  D, P=distancias(x,y,links,ind,src,D,P)
  ca,Lo=costeo(ind=ind, x=x,y=y, links=links, D=D,P=P, src=src, draw=False)
  if(Lo<Lmin):
    Lmin=Lo
    bestCar=ca
  resultado.append((N,Lo))

X=[(xi, yi) for xi, yi in zip(x,y)]
xi, yi=np.meshgrid(np.linspace(-L,L,100), np.linspace(-L,L,100))
Z=[r[1] for r in resultado]
pos=np.argmin(Z)

from scipy.interpolate import griddata
zi=griddata(X, Z, (xi,yi), method='linear')
plt.figure(figsize=(12,12))
plt.contourf(xi,yi,zi,50)
plt.colorbar()
plt.axis('equal')
dibujar(x,y,demanda,links)

for i,dem in demanda.items():
  plt.plot(x[i],y[i],'sb', markersize=dem)
plt.plot(x[pos], y[pos], '*r', markersize=30)

for ca in bestCar:
  xp=[x[i] for i in ca]
  yp=[y[i] for i in ca]
  plt.plot(xp,yp,'-', linewidth=2)